Stack-Based MultiPass Frequency Analyzer 
(Project Report) 
1. Executive Summary 
This project implements a frequency counter that uses stack operations as the primary data 
structure mechanism. Instead of counting frequencies in a single pass using arrays or direct 
indexing, the program first pushes all input values onto a stack, then pops values to compute 
and print frequencies. The implementation is written in a simple assembly-like ISA and includes 
custom stack-related machine instructions and microinstructions (push, pop, and stack memory 
behavior). Screenshots of the running output and instruction definitions are included as figures 
in this report. 
2. Project Requirements (Hard Version) 
• Push all numbers onto a stack first (reverse order). 
• Pop elements one-by-one and process them using another stack that stores pairs (value, frequency). 
• Detect duplicates only using stack operations (no direct indexing/arrays). 
• Rebuild a sorted frequency list (ascending or descending by count) using stack operations only. 
3. Design Overview 
The implementation in the provided screenshots follows a multi-stage stack workflow: 
1. Input Stage:  
                         Read N, then read N integers and push each value onto the DataStack. 
2. Analysis Stage:          
                             Pop values from the DataStack to compute frequencies and print (value, 
frequency) pairs. 
3. Instruction-Level Support:  
                                                      Define/verify stack-related instructions and microinstructions for 
push/pop and stack memory access. 
4. Implementation Details 
4.1 Assembly Program Structure 
The main program performs the following sequence: 
• Read N (number of inputs) and initialize loop index i = 0. 
• Call ReadAndPush to read N values and push them onto the stack. 
• Initialize count = 0 and call FrequencyPrint to pop values and output frequencies. 
• Stop execution. 
Code: 
Start: 
  read 
  store N 
  load ZERO 
  store i 
  call ReadAndPush 
  load ZERO 
  store count 
  call FrequencyPrint 
  stop 
 
; Read N values and push onto stack 
ReadAndPush: 
RLoop: 
  load i 
  subtract N 
  jmpz RDone 
  read 
  store CUR 
  push CUR 
  load i 
  add ONE 
  store i 
  jump RLoop 
RDone: 
  return 
 
; Pop stack and print value + frequency 
FrequencyPrint: 
  pop PREV 
  load ONE 
  store FREQ 
 
  load count 
  add ONE 
  store count 
 
FreqLoop: 
  load count 
  subtract N 
  jmpz PrintLast 
 
  pop CUR 
  load CUR 
  subtract PREV 
  jmpz SameValue 
 
  ; print previous value and frequency 
  load PREV 
  write 
load FREQ 
write 
; reset for new value 
load CUR 
store PREV 
load ONE 
store FREQ 
load count 
add ONE 
store count 
jump FreqLoop 
SameValue: 
load FREQ 
add ONE 
store FREQ 
load count 
add ONE 
store count 
jump FreqLoop 
PrintLast: 
load PREV 
write 
load FREQ 
write 
return 
; DATA SECTION 
ZERO: .data 2 0 
ONE:  .data 2 1 
N:    
.data 2 0 
i:    
.data 2 0 
count:.data 2 0 
CUR:  .data 2 0 
PREV: .data 2 0 
FREQ: .data 2 0 
Note: The FrequencyPrint routine counts consecutive equal values while popping from the stack. 
Therefore, it correctly aggregates duplicates when equal numbers are adjacent in the pop order 
(i.e., the input values are grouped). To satisfy the “Hard Version” requirement for detecting 
duplicates in an arbitrary order, an additional pair-stack pass is typically required (see Section 6). 
4.2 Stack Instruction and Microinstruction Support 
The screenshots show edits to the machine instruction set and microinstruction sequences that 
implement stack behavior: push/pop instructions, stack memory access to DataStack, and 
call/return-related behaviors. These definitions ensure values can be pushed to and popped 
from stack memory using only stack operations. 
5. Testing and Output Screenshots 
Two sample runs are shown in the provided screenshots. The program reads N followed by N 
integers, then prints each value alongside its frequency.
7. Hard-Version Extension (Recommended Design) 
To fully meet the “Hard Version” requirements for arbitrary input order and for sorting by 
frequency, the following stack-only multi-pass strategy is recommended: 
• Pass 1 (Reverse): Push all N input numbers onto Stack S1 (already implemented). 
• Pass 2 (Build Pair Stack): Pop each value x from S1 and update a pair-stack S2 that stores (value, 
freq). To update, pop pairs from S2 into a temporary stack until you find value x, increment its 
frequency, then rebuild S2 back (all using push/pop). If x is not found, push a new pair (x,1). 
• Pass 3 (Sort by Frequency): Use two stacks to perform a stack-based insertion sort on pairs in S2 
by frequency (ascending/descending). For each pair popped from S2, insert it into the correct 
position of S3 by moving elements between stacks. 
• Pass 4 (Output): Pop the sorted stack and print (value, frequency) in the required order. 
8. Conclusion 
This project demonstrates a stack-driven approach to frequency analysis and documents the 
ISA/microinstruction work necessary to support push/pop operations. The provided 
implementation successfully reads inputs, pushes them onto a stack, and prints value-frequency 
pairs during stack popping for grouped inputs. With the recommended extension (pair-stack 
update + stack-based sorting), the solution can be expanded to fully satisfy the hard-version 
requirements for arbitrary input order and frequency-sorted output.
